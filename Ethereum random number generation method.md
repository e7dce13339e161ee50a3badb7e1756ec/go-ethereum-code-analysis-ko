당신이 달성해야하는 경우 카지노 광장 이더넷 기반의 카지노를 분산 최근의 실현을 고려하고 임의의 숫자는 필수입니다. 그리고 쉽게 찾을 수없는, 내부의 작은 난수 생성 이더넷 광장을 공부합니다.


여러 가지 방법으로 임의의 숫자를 생성 에테르 광장.


# oraclize
Oraclize는 신뢰할 수있는 링크로 웹 API와 DApp에 포터에 데이터 센터 애플리케이션으로 위치. 우리의 행동이 암호화 된 인증으로 강제되어 있기 때문에 Oraclize으로, 신뢰의 추가 체인을 구축 할 필요가 없습니다. Oraclize는 인터넷에 액세스 할 수 있습니다 스마트 계약을 할 수있는 증명 정직 오라클 서비스입니다. Oraclize 모든 주요 계약 지능형 플랫폼 기능을위한 가상 인터페이스를 제공, 플랫폼에 독립적이다. 블록 체인 의미있는 데이터로 수천, 당신은 지능형 계약 산업 더 번영하고 더 가치있는 응용 프로그램을 전시 큰 활력을 할 수 있다는 것을 생각할 수있다.

사용 Oraclize 다음 [코드]를 참조 할 수 있습니다 (https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)

오라클의 스마트 계약 내부의 코드를 호출하는 방법 업데이트 방법을 oraclize_newRandomDSQuery 전화
오라클 대응하는 데이터 요청에 따라 생성되고, 그 결과는 콜백 __callback 통과.

	/*
	   Oraclize random-datasource example
	
	   This contract uses the random-datasource to securely generate off-chain N random bytes
	*/
	
	pragma solidity ^0.4.11;
	
	import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";
	
	contract RandomExample is usingOraclize {
		
		event newRandomNumber_bytes(bytes);
		event newRandomNumber_uint(uint);
	
		function RandomExample() {
			oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor
			update(); // let's ask for N random bytes immediately when the contract is created!
		}
		
		// the callback function is called by Oraclize when the result is ready
		// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:
		// the proof validity is fully verified on-chain
		function __callback(bytes32 _queryId, string _result, bytes _proof)
		{ 
			// if we reach this point successfully, it means that the attached authenticity proof has passed!
			if (msg.sender != oraclize_cbAddress()) throw;
			
			if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
				// the proof verification has failed, do we need to take any action here? (depends on the use case)
			} else {
				// the proof verification has passed
				// now that we know that the random number was safely generated, let's use it..
				
				newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)
				
				// for simplicity of use, let's also convert the random bytes to uint if we need
				uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return
				uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range
				
				newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)
			}
		}
		
		function update() payable { 
			uint N = 7; // number of random bytes we want the datasource to return
			uint delay = 0; // number of seconds to wait before the execution takes place
			uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function
			bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId
		}
		
	}

스마트 내기를 제공하는 계약을 고려하십시오.
그런 다음 사용자는 사용자의 요청을 저장할 오라클 난수 생성 서비스를 호출합니다 내기 인터페이스를 호출합니다.
설정 한 경우 오라클 콜백 서비스가 임의의 숫자가 특정 값보다 큰지 여부를 결정하기 위해, 사용자는 다른 사용자가 실패, 성공.

이것은 전형적인 오라클 사용 사례입니다.






# RANDAO: A DAO working as RNG of Ethereum

[randao](https://github.com/randao/randao) 이더넷 광장 분산 된 조직 생성 된 난수이며,

**Random number in programming is very important!**

**RNG in a deterministic system is very difficult**

**Miners can't be trusted!**

프로그램의 임의의 숫자는 매우 중요합니다.
결정적 RNG 시스템에서 매우 어렵다.
광부는 믿을 수 없어

## 솔루션
Solutions

A DAO (decentralised autonomous organisation) that anyone can participate in, and the random number is generated by all participants together! First of all, we need to create a RANDAO contract in the blockchain, which defines the participation rules. Then the basic process of generating a random number can be divided into three phases:

(익명으로 분산)는 DAO 누구나 가입 할 수는 임의의 숫자는 모든 참가자의 협력 생성됩니다. 우선, 우리는 블록 체인의 스마트 계약 RANDAO를 작성해야, 계약은 계약의 규칙을 정의합니다. 기본 프로세스는 임의의 숫자는 다음과 같은 세 단계로 나눌 수 있습니다 생성됩니다

**The first phase: collecting valid sha3(s)**

Anyone who want to participate in the random number generation needs to send a transaction to the contract C with m ETH as pledge in a specified time period (e.g, 6 block period, approximately 72s), accompanied by the result of sha3(s), s is the secret number respective picked by participant.

** 첫번째 단계 : 유효 SHA3 (들)를 수집 **
난수 생성에 관련된 참가자 스마트 투과형 SHA3 (S)의 값과, C를 수축으로 (예를 들어, 여섯 개 블록 간격, 약 72 초), 스마트 담보 m의 ETH에 송신하는 제 지정된 시간 간격에 필요한 계약 C는 S는 자신의 번호를 알고있는 참가자이다.

**The second phase: collecting valid s**

After the first phase, anyone who submitted sha3(s) successfully needs to send a transaction with the secret number s in the first stage to contract C within a specified time period. Contract C will check if s is valid by running sha3 against s and comparing the result with previous committed data. Valid s will be saved to the collection of seeds to finally generate the random number.

** 2 단계 : 유효한의 수집 **

첫 단계 후, 참가자 SHA3 (들)에 의해 제출 된 간격들은 지능형 스마트 계약 계약 C. C 검사의 SHA3 (들) 및 값을 제출하기 전에 동일한 지정된 시간 내에들로 전송 될 필요가있다. 종자의 저장됩니다 같은 궁극적으로 임의의 숫자의 집합을 생성하는 데 사용됩니다.

**The third phase: calculating a random number, refund pledged ETH and bonus**

- After all secret numbers have been successfully collected, contract C will calculate the random number from the function f(s1,s2,...,sn), the result will be written to the storage of C, and the result will be sent to all other contracts that requested the random number before.
- Contract C will send back the pledge to the participants in the first phase, and the profit is divided into equal parts and sent to all participants as an additional bonus. The profit comes from the fees that is paid by other contracts that consume the random number.

** 세 번째 단계 : 모기지과 보너스를 반환, 임의의 수를 계산 **

- 모든 비밀 번호 (S)를 수집 성공적 후, C는 임의의 숫자를 계산하는 (S1, S2, ..., SN) 지능형 계약 함수 f를 사용하여, 결과는 스마트 계약의 메모리에 기록 된 난수 것이지만 결과 그것은 위의 임의의 숫자를 요청하기 전에 다른 모든 스마트 계약에 전송됩니다.
- 지능형 모기지 계약 C가 첫 번째 단계의 참가자에게 반환됩니다, 다음 보너스 동일하게 모든 참여자에게 할당 된 분할됩니다. 다른 스마트 요청 임의의 값에서 보너스 계약.

## Additional rules

In order to ensure the RNG can't be manipulated, as well as for safety and efficiency, the contract C has the following additional rules:

- The first phase, if two or more of the same sha3(s) are submitted in sequence, only the first one is accepted.

- The first phase, there is a requirement for minimum number of participants, if it fails to collect enough sha3(s) within the time period, then RNG at this block height will fail.

- If a participant submits the sha3(s) and it is accepted by contract C, he must reveal the s in the second phase.

	- If the participant fails to reveal s in the second phase, then the m ETH sent in the first phase will be confiscated without providing a return.

	- If one or more s isn't revealed in the second phase, RNG at this block height will fail. Confiscated ETHs will be divided equally and send to other participants who revealed s at the second phase. The fees paid by other contracts will be refunded.

보충 규칙

위해서는 RNG뿐만 아니라 안전하고 효율적으로 조작 할 수 없도록, 스마트 계약 C는 다음의 추가 규칙이 있습니다 :

- 두 개까지 제출 같은 SHA3 (들)의 이상이있는 경우 첫 번째 단계에서는 첫 번째 명령 만이 허용됩니다.
- 첫 번째 단계, 참가자에 대한 최소 요건에있어서, 지정된 시간 간격 내에 충분한 값 SHA3 (들)를 수집하지 않으면, RNG 높이가이 블록에 실패 할 것이다.
- 참가자가 SHA3 (들)을 제출 한 경우에, 그는 두 번째 단계의에 제출해야합니다
	- 참가자가 두 번째 단계의를 제출하지 않은 경우, m의 ETH의 첫 번째 단계는 몰수하지 않고 보상됩니다 제공합니다.
	- 하나 개 이상의 (S)가 제 2 단계에서 전송되지 않은 경우, RNG 높이가이 블록에 실패한다. 압수 ETH는 동등의의 다른 참가자들에게 배포에 제출됩니다. 응용 프로그램의 다른 계약 기타 비용 난수가 반환됩니다.

## Incentive

The RNG cycle is very short, and could be for example 20 cycles in one hour, if one cycle's profit is 0.001% , the monthly rate of return is up to 0.00001 * 20 * 24 * 30 = 0.144. Targeting to 14.4% monthly rate of return, and RNG has n participants on average, the running costs of contract is n * 3 * 500 * gasPrice + Ccost. (Ccost is gas consumed by contract internally, including computing and storage, etc. ) Assuming each random numbers has r time requests on average, the call price is p ETH, the income is r * p. So each participant will get (rp - 1500n * gasPrice - Ccost) / n from one time participation. The current gasPrice is 10 szabo, and estimate of contract consumption is 1500n gas, so estimate of net income is (rp / n - 0.03) ETH. Assuming each RNG has 10 participation, and the pledge is 1000ETH, the minimum required income is 0.4 ETH, which over 0.001% profit in this case. So if the RNG is requested only once, the service price is 0.4 ETH, and if it is requested 10 times, the price is just 0.04 ETH for each request.

자극

어떤 기간이 0.001 %,없는 경우 RNG주기는 월 이익은 * 20 * 24 * 30 = 0.144 0.00001에 도달 할 것, 예를 들어, 한 시간 20 수익 창출 기간이 매우 짧다. 한달에 14.4 %의 이익이고, n의 RNG 참가자의 평균 C n에 대한 스마트 계약을 실행하는 비용을 달성하기 위하여 * 3 * 500 * gasPrice + Ccost. (연산 및 저장을 포함한 가스 계약 CCost 내부 소비) . 1500N의 *의 gasPrice - - Ccost) / n은 각 참가자가 참가마다의 RP를받을 수 있도록 요청 수수료 당 요청 각각 임의의 값 r에 평균, P는 ETH이라고 가정하면, 다음 소득은 r에 * 피입니다. 현재 gasPrice는 소비자 계약은 아마 1500N 가스 (10) 자보이다, 그래서 아마 순이익 (RP / N-0.03) ETH입니다. 각 RNG는 10 명을 가지고 있다고 가정하고, 저당, 1000ETH 경우에만 RNG 그렇다면 요청이 10 배, 그 가격이 요청됩니다 한 번 0.04ETH로 감소하는 경우 수수료가 0.4 ETH되면 다음 번 요청


The RANDAO acts as an infrastructure in the Ethereum system. It is called by other contracts. Contracts for different purposes require different random numbers: some need high security, such as lottery; some need steady responses and the request should be responded immediately, these contracts are normally low-value; some need a callback, they want to receive a notification with random numbers when numbers are ready.

Obviously it's impossible to meet different requirements in various scenarios with only one RNG contract, so a lot of contracts will be created with different initial parameters, but the basic rules are the same.

이더넷 인프라 시스템과 같은 RANDAO 광장. 그것은 다른 계약에 의해 호출됩니다. 그것은 다른 임의의 값을 필요로하기 때문에 다른 계약이 다른 목적을 가지고 : 일부는 추첨으로, 암호화의 높은 수준을 요구, 일부는 안정된 응답을해야하고, 즉각적인 응답을 요구,이 계약 자체의 값이 높지 않다, 일부는 콜백 함수가 필요, 임의의 값을 생성 할 때 이미 알림을 수신 할 필요가있다.

분명히 하나의 계약을 통해 RNG는 다른 모든 요청을 충족, 똑똑 계약을 많이 만들 다른 초기 값을 사용하지만, 자신의 기본 규칙은 동일 할 수 없다.


For example, if we need high security, we can substantially increase the pledge of the first phase. Thus, the cost of leading to failure of RNG process by not revealing s is greatly increased. And for the contracts without much interest involved, the minimum number of participants and the pledge can be lower.

Let's look at an example of a dApp betting on odd or even numbers, we'll show how to adjust the contract's parameters to meet the desired security level, by making the cost of cheating higher than expected earnings. Assuming the bet is 1000 ETH, the betting contract calls a RNG contract C1, if C1 failed to generate a random number at requested block height, then betting contract waits for the next random number of C1, until there is one generated.

예를 들어, 고도의 보안을 필요로하는 경우, 우리는 크게 모기지 첫 번째 단계를 증가시킬 수있다. S 이것은 실패 확률 리드가 크게 감소 될 것이다 제공하지 않는다. 매우 적절한 자금 조달 계약이없는 경우, 다음 참가자의 최소 수와 주택 담보 대출이 감소 될 수있다.

의는 dapp에서 홀수 및 짝수 내기에 사용되는 예를 살펴 보자, 우리는 어떻게 혜택의 비용보다 훨씬 높은 사기를함으로써, 보안의 적절한 수준에 맞게 계약의 매개 변수를 조정하는 방법을 보여 드리겠습니다. 블록의 높이가 실패한 요청의 난수를 생성하는 경우 내기 1000ETH, 베팅 계약이라고 RNG 계약 C1, C1 가정, 세대의 성공이있을 때까지 다음 난수 C1을 기다리는 계약을 내기.

Let's build the RNG contract C1, and set the pledged ETH of C1 to 2000. The gambler G plays the betting dApp but also participates in the contract. When he finds himself in a disadvantageous position before he reveals his secret number, he can choose not to reveal s, so that the RNG failed and he got another chance. But he will lose the 2000 pledged ETH, so although he can get 1000 ETH expected return, it is still a bad deal. However, G can reduce his losses on C1 by some means, such as participating in C1 using two accounts, sending two sha3(s). if in a disadvantageous position, G will keep only one account's secret, and if only one participant expect G participate to in C1, G will only lose 1000 ETH in C1, but G will get 1000 ETH as expected return, which is a worthy try.

의 스마트 계약 RNG C1을 구축하고, 주택 담보 대출의 값이 2000입니다 설정할 수 있습니다. G 도박꾼은 계약 RNG의 지능에있는 동안 참여, dApp 참여 내기. 그는 S를 제출하기 전에, 불리한 조건에서 자신을 찾을 수 있습니다. 그는 RNG가 실패 할 수 있도록, 그는 다음 기회를 얻을 수 있습니다, 자신의의를 제출하지 않도록 선택할 수 있습니다. 그러나 그가 내기 1000ETH을 얻을 수 있지만 그는 모기지 2000ETH을 잃게됩니다, 그래서 이것은 좋은 거래하지 않습니다. 도박꾼 G가 손실을 줄이기 위해 다른 방법을 사용할 수있다 그러나, G 등 두 전송 SHA3 (들). 부정적인 상태 경우, 계정, G의 제출되지 않습니다 RNG 두 계정에 관여 할 수있다 그래서 G뿐만 아니라 경우 또 다른 추가는 하나의 다른 계정 1000ETH 위의 G1에서 G 유일한 손실이지만, G가 우승하면 좋은 방법은 1000ETH 될 수 있으므로 시도 가치가있다.

This issue can be fixed by confiscating the pledged ETH, and not return them to participants as bonus. so a contract with 1000 pledged ETH will meet the requirement of the betting dApp.

이러한 상황은 모든 주택 담보 대출의 몰수 의해 복구 할 수 있습니다, 그들은 보상으로 반환하지 않습니다. 그래서 1000 저당 계약은 도박의 요구 사항을 충족합니다.

Besides confiscation, another scheme can prevent such attacks by introducing an additional system: RANDAO membership. To become a member you must pay dues, anyone paid their dues is a member. Members have different levels according to the dues they paid. Membership does not belong to a contract, but instead functions like a passport to participate in some RANDAO contracts. If a breach of any contract happens, that person's membership will be ended and the dues will be confiscated. Now we can add an additional agreement to C1, C1 will only accept numbers committed by members whose level of investment is high enough (membership dues over 1000 ETH). This will ensure that nobody has a financial motive to try an attack.

몰수뿐만 아니라, 이러한 공격을 방지 할 수있는 프로그램 이외에, 그것은 RANDAO 회원입니다. 회원이되기 위해서는 회원 수수료를 지불해야합니다. 수수료는 다른 수준의 구성원으로 유료 회원 얼마나에 따라 정보 시스템의 회원은 계약에 속하는하지 않지만 일부 RANDAO 계약에 참여하는 여권과 유사한 형태로. 회원의 회원 자격이 종료, 디폴트가 발생하면, 회원은 몰수됩니다 사용합니다. 이제 우리는 추가 프로토콜을 추가하는 스마트 계약 C1은 C1 만 참여할 수있는 특정 값 회원 이상으로 회원을 받아 줄 수 있습니다. 그래서 아무도 공격 할 수있는 재정적 인 인센티브가 없다는 것을 확인합니다.


## QA: Quest and Answer

Q: Why not let the miners participate in RNG? Why not use tx hash, nonce and other blockchain data? A: Miners have the ability to manipulate these blockchain data, and thus can indirectly affect RNG. If RNG contains blockchain data, it will give the miners capacity to construct random numbers in their favor.

Q :하지 왜 광부는 RNG에 참여? txhash, 논스 또는 다른 데이터 블록 사슬 A를 사용하지 왜 :? 광부에만 영향 RNG있을 것이다 데이터 블록 사슬을 조작하는 기능을 갖는다. RNG 블록 사슬 데이터를 포함하는 경우, 난수 광부 구조를 수행하는 그들의 능력에 따라 설명한다.

Q: the miners can ignore certain transactions that contain random number they dislike, how to deal with that? A: That's why we need a time window period. A reasonable period should be greater than 6 blocks, we believe that nobody can produce 6 blocks in succession. So if the participant is honest, and he send numbers immediately as long as each time window open, he doesn't need to worry about being excluded.

Q : 광부, 어떻게이 상황을 임의의 숫자를 다루는 포함 특정 트랜잭션을 무시할 수있는 능력을 가지고? 답변 : 우리가 시간 간격을 필요로하는 이유입니다. 합리적인 시간 간격 우리는 지속적으로 여섯 개 블록을 생성 할 수 있습니다 아무도 강제하지, 이상 여섯 개 블록 될 것입니다. 참가자들이 충성하지만, 그 수는 시간 창 내에서 전송되는 경우 그래서, 그는 다른 걱정 제외 광부 될 것입니다.

Q: Why use all numbers of all participants, rather than a subset? A: The rule to pick a subset is deterministic, so participants will try to take specified position of the collection by various means, if they succeed, they will know in advance what the random number is generating from subsets. If the rule to pick a subset is randomised, then we still have the problem of true randomisation.

Q : 왜 모든 모든 참가자의 값이 아닌 부분 집합? A는 : 참가자가 하위 초점에서 생성 된 난수를, 설정된 위치를 지정하는 그들이 성공하는 경우, 사전에 알 수 다양한 방법을 수집하려고 시도합니다, 그래서 일부 규칙이 결정적 선택합니다. 이 규칙의 하위 집합을 선택하면 그 다음 우리는 여전히 실제 문제 랜덤입니다 무작위입니다.

질문 : 약속 않습니다 회비가는 :? 그것은 자선 단체에 기부됩니다, 또는 RANDAO 자금의 Q를 유지하기 위해 :. 비용이 어디를 압수합니다. 그것은 자선 단체에 기부됩니다, 또는 RANDAO는 펀드를 유지한다.

Note: f(s1, s2, ..., sn) is a function with multiple inputs, for example r = s1 xor s2 xor s3 ... xor sn, or r = sha3(sn + sha3(sn-1 + ... (sha3(s2 + s1))))

