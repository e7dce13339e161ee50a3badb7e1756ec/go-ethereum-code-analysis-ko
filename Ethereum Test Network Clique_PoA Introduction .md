https://github.com/ethereum/EIPs/issues/225

파벌 모드에서 사용자가 더 광산 없다, 그래서 당신은 이더넷 통화를해야하는 경우, 필요가 특별한 방법을 얻을 수 있기 때문에, 에테르 통화를 얻을 수 없습니다.

에테르는이 웹 사이트를 통해 얻을 수 있습니다

https://faucet.rinkeby.io/

당신은 위의 참조 사이트를 얻을 수있는 자세한 방법을 얻기 위해 + 계정, 페이스 북이나 트위터 계정을 구글이 필요합니다.



파벌 지금은 주로 Rinkeby 테스트 네트워크에서 사용 권한의 전원 이더넷 광장 실현이다.

## 배경

첫 번째 공식 테스트 이더넷 네트워크 광장 Morden의입니다. 그것은 결국 다시 시작 testnet을 중지하기로 결정 때문에 Geth 정크 및 testnet의 패리티 간의 문제 합의의 축적 년 7 월 2015 년 11 월 2016 년입니다.

Ropsten은 모든 쓰레기를 청소 깨끗한 상태에서 시작, 태어났다. 런 월 2017이 끝날 때까지 지속, 나쁜 배우 탕을 남용하고, 점차적으로 정상 4700000-9000000000에서 이번에는 네트워크를 통해 큰 거래 피해를 보내는 GasLimit을 증가 결정할 때. 심지어 그 전에, 공격자는 다른 네트워크 클라이언트, 심지어 다른 버전 사이의 분할에 이르는 매우 긴 사슬 구조 조정의 번호를 차단하려고합니다.

보안 포로 네트워크 및 컴퓨팅 파워 뒤에 안전이 공격의 근본 원인. 공격자가 반복적으로 같은 공격을 설치할 수 있기 때문에 새로운 테스트 네트워크는, 어떤 문제가 해결되지 않으면 처음부터 다시 시작합니다. 패리티 팀은 부드러운 십자가의 특정 임계 값을 초과 할 수하지 않는 GasLimit을 개발하기 위해, 블록을 많이 롤백 긴급 솔루션을하기로 결정했다.

이 솔루션은 단기적으로 작동 할 수 있지만 :

이 우아한되지 않습니다 : 이더넷 광장 동적 제한해야
이것은 휴대용되지 않습니다 : 다른 고객이 새로운 포크 로직을 구현해야
빠른 동기화 및 빛 클라이언트 운 : 그것은 동기 모드와 호환되지 않습니다
이것은 단지 공격 시간을 연장 : 쓰레기 여전히 지속적으로 끊임없는 경우 아래의 수
패리티 솔루션, 완벽한, 그러나 아직도 가능하지 동안. 나는 대체 솔루션 더 포함하는 장기적인를하고 싶습니다,하지만 적절한 시간 내에 출시 될 수있을 정도로 간단해야한다.


## 표준화 POA

전술 한 바와 같이, 네트워크의 값은, 탕 안전하게 작업 할 수 없습니다 있습니다. 이더넷 광장의 PoS 장기적인 목표 캐스퍼는 기반, 그러나 이것은 지루한 연구이다, 그래서 우리는 오늘의 문제를 해결하기 위해 곧 이것에 의존 할 수 없다. 그러나, 하나 개의 솔루션이 제대로 테스트 네트워크를 수리 구현하기 쉽고, 충분한 효과, 즉 권위있는 증거 기법 (증명 권한 계획)입니다.

필요 이상으로 복잡하게 보이는, 많은 계약 문서가 아니지만 패리티가 달성 POA를 가지고 않지만, 볼 그리고 다른 고객 분들과 재생 어려울 수 있습니다. 나는이 제안을 나에게 더 많은 피드백을 제공하기 위해 자신의 경험을 바탕으로 그들을 환영합니다.

주요 설계 목표의 POA 프로토콜은 여기에 설명 된 클라이언트 개발자를위한 필요없이, 구현 및 동기식 기술 (빠르게, 쉽게, 왜곡) 기존의 사용을 허용하면서 내장 기존의 이더넷 광장 클라이언트가 매우 간단해야이다 중요한 소프트웨어에 사용자 정의 로직을 추가 할 수 있습니다.

## PoA101

방법 POA 작업을 실현하지 않는 사람들을 위해,이 광부가 어려운 문제를 해결하고 경쟁, 승인 된 서명 언제든지 새로운 블록을 만들지 여부를 결정할 수 있습니다보다는 매우 간단한 프로토콜입니다.

동적으로 다른 서명자와 서명자의 목록을 조정하는 방법 부하 (기회)를 배포하는 방법 광산의 주파수를 제어 할뿐만 아니라 방법의 주위에 도전. 다음 섹션에서는 권장되는 치료 프로토콜에게 이러한 모든 시나리오를 정의 할 수 있습니다.

## Rinkeby proof-of-authority

전반적으로, 동기 블록 사슬의 두 가지 방법이있다 :

- 기존의 접근 방식은 하나 하나 개의 시작 블록과 포장 된 의해 수행 모든 거래를 넣어하는 것입니다. 이러한 방식으로 시도하고, 광장이 복잡 이더넷 네트워크에 매우 시간이 많이 소요되는 컴퓨팅 자원을 것으로 입증되었습니다.
또 첫 번째 블록 사슬을 다운로드 및 네트워크가 임의의 상태 및 최신 검사 최신 헤더로부터 다운로드 할 수있는 후 자신의 유효성을 확인하는 것이다.
- 블록 만 완료하기 위해 신뢰할 수있는 사람이 서명 할 수 있다는 생각에 따라 POA 방식. 따라서, 각 블록 (또는 헤더) 클라이언트가 신뢰 서명자와 일치하는 목록을 볼 수있다. 여기에서 문제는 인증 된 서명자 목록의 적절한 변화를 유지하는 방법은? 확실한 대답은 (계약 에테르 광장 점에있을 것입니다) 잘못된 답변입니다 : 빠른 동기화가 액세스 할 수없는 상태입니다 동안.

** 유지 보수 계약 허가 서명자 목록은 완전히 블록 헤더에 포함되어야합니다. **

다음 명백한 아이디어는 포로의 개념을 포기하고 투표 장치를 수용하고 새로운 분야를 소개 할 수 있도록 블록 구조의 제목을 변경하는 것입니다. 이것은 잘못된 답변입니다 : 같은 데이터 구조의 핵심은 더 구현, 유지 보수 및 안전 악몽에 개발 될 것이다 변경합니다.

** 유지 보수 계약 허가 서명자 목록은 완벽하게 현재의 데이터 모델에 적합해야합니다. **

따라서, 위의에 따라, 우리는 투표 EVM을 사용하지만, 존 헤더 리조트했다 없습니다. 그리고 우리는 헤더 필드 영역을 변경하고 현재 사용할 수있는 필드에 의존했습니다 수 없습니다. 선택의 여지가 없습니다.

### 다른 분야의 다수의 헤더 영역은 투표 및 서명을 달성하기 위해

가장 명백한 흥미로운 필드는 단지 현재의 메타 데이터의 일부로서 사용된다 ExtraData에게 블록 헤더 32 바이트이다. 광부 보통 클라이언트와 버전이있는, 그러나 어떤 사람들은 추가로 채우기 &quot;에 대한 정보를 제공합니다.&quot; 프로토콜은 KEC 65 바이트 서명 광부를 개최 높이기 위해이 분야를 확장합니다. 이 사람이 승인 된 서명자의 목록에 대해 검증 블록을 얻을 수 있습니다. 또한 무효의 헤더 ​​영역 주소 필드 광부한다.

모든 코드 (예를 들어 RLP 인코딩, 해시) 알 수 있기 때문에 클라이언트가 사용자 지정 논리를 필요로하지 않도록 헤더 영역의 길이를 변경하면, 비 침습적 절차 있습니다.

충분한 이상이 체인의 유효성을 검사하지만, 우리는 서명자의 동적 목록을 업데이트 할 방법에 대해 설명합니다. 그 대답은 우리가 필드 수혜자와 투표 계약을 작성하는 POA 넌스 필드 포기 새로 오래된 광산을 다시 사용할 수 있다는 것입니다 :

- 종래의 블록에서, 이러한 두 필드는 0으로 설정 될 것이다.
- 서명자의 소원이 승인 된 서명자 목록을 변경하는 경우, 그것은 것입니다 :
	- 광부 필드는 ** 설정 ** 수혜자는 희망의 서명을 투표
	- ** 넌스은 ** 0으로 설정됩니다 또는 0xff가 ... F 또는 킥 투표에 추가

상관 동기 체인 클라이언트는 데이터 블록 처리에서의 투표 &quot;계산&quot;, 일반 로그인하여 서명자인가 된 변경의 동적리스트를 유지할 수있다. 생성 블록 서명자에 의해 제공되는 파라미터의 초기 그룹 (초기 상태 배포 계약 &quot;초기 유권자리스트&quot;의 복잡성을 피하기 위해).

투표를 계산하고, 쓸모없는 제안을 주기적으로 제거 할 수 무제한 창을 방지하기 위해, 우리는 시대가, 각 시대의 변환이 보류중인 모든 투표를 플래시합니다 ethash 개념을 다시 사용할 수 있습니다. 또한, 이러한 획기적인 전환은 현재 머리 추가 데이터 서명자 목록에 허가 된 상태가없는 체크 포인트를 포함 할 수있다. 이것은 클라이언트가 체인의 모든 투표를 재생하지 않고 단지 해시 기반의 체크 포인트를 동기화 할 수 있습니다. 또한, 초기 작성 부 완전히 정의 블록 사슬을 포함하는 서명자 허용

### 공격 벡터 : 악성 서명자

발생할 수있는 악의적 인 사용자가 서명자의 목록 또는 위협을 받고 서명자 키 / 기계에 추가됩니다. 이 경우, 계약은 구조 조정과 스팸 메일에 저항 할 수 있어야합니다. 제안 된 해결책은 (는) N 소정인가 서명자의 목록을 제공한다는 것이다, 어느 한 블록의 서명자 만 K. 각각에 충전 될 수있다 이것은 손상이 제한되는 것을 보장하고, 광부의 나머지 부분은 악의적 인 사용자 캐스트 할 수 있습니다.

## 공격 경로 : 검토 서명자

서명자 (또는 서명자의 그룹)가 승인 된 목록에서 제거하기 위해 블록 체크 아웃하려고하면 또 다른 흥미로운 공격 벡터이다. 이 문제를 해결하기 위해, 우리는 N / 2의 서명자 최소 허용 주파수를 제한한다. 이것은 악의적 인 서명자이 경우, 게임에 갈 수없는 경우에, 서명 계정의 적어도 51 퍼센트 제어해야하는 것을 보장한다.

## 공격 경로 : 스팸 서명자

마지막으로, 작은 악의적 인 공격 벡터는 각 블록 내에서 새로운 투표 권장 사항을 주입하는 서명됩니다. 노드 이후 승인 된 서명자의 실제 목록을 만들 수있는 모든 투표를 계산해야하는, 그래서 그들은 모든 시간의 트랙이 투표를 계속해야합니다. 이 서서히 증가 할 수에는 제한 투표 창은 없지만 제한이 없습니다. 용액을 블록 W 움직이는 윈도우에 배치되어, 그 응답은 사용되지 않는 것으로 간주된다. 창은 합리적인 연령 1-2 될 수있다. 우리는 시대라고 부른다.

## 공격 경로 : 동시 블록

인가 서명자의 수가 N이고, 우리는 블록 K의 각 서명자 충전을 허용하면, 언제든지 NK 광부는 박하 허용된다. 이 블록에 대한 경쟁을 방지하기 위해, 각 서명자는 작은 임의 &quot;오프셋&quot;해제 새로운 블록을 추가합니다. 이 작은 포크가 드물지만 가끔 (예 : 주요 네트워크로) 발생하는 것을 보장한다. 권위와 혼란의 학대의 서명자, 그래서 서명이 퇴장 할 수있는 경우.

## 주의

### 이것은 우리가 리뷰 testnet를 사용하는 것이 좋습니다 것을 의미합니까?

이 테스트에 제안이 특정 스팸 필터링 기능이 계정에 특정 악성 배우의 특성을 고려하고, &quot;독점 자본&quot;포로 네트워크 계획의 약점의 관점에서, 그것은 네트워크를 구축하는 것이 가장 좋습니다 것을 보여주고, 개발자들은 의지 할 수 그 절차.

사양 왜 POA?

다른 고객은 다른 상황에서 더 좋을 것이다. 서버 환경에 큰있을 수 있습니다 이동하지만, CPP는 RPI 제로에서 실행에 더 적합 할 수있다.

수동 투표는 너무 많은 문제가 아닌가요?

이것은 구현 세부이지만, 서명자, 계약에 따라 투표 전략을 사용 EVM의 모든 기능을 활용할 수있는 유일한 결과는 검증의 평균 헤드 노드에 푸시됩니다.

## 명확화 및 피드백

- 제안은 클라이언트 기반 포로 테스트 네트워크를 실행 배제하지 않거나 여부를 Ropsten 새로운 테스트 네트워크를 기반으로합니다. 이상적으로 고객에게 포로와 POA 기반의 테스트 네트워크 연결 방법 (# 225 (리뷰)).

- 프로토콜 매개 변수는 클라이언트의 가해자의 파괴를 구성 할 수 있지만, Rinkeby 네트워크는 주요 네트워크에 가능한 한 근접해야하지만. 이것은 동적 GasLimit, 가변 블록 시각 약 15 초, GasPrice 등을 포함한다 (# 225 (평가)).

-이 프로그램이 보장하는 한, 언제든지 적어도 K 서명자 인터넷을 필요로하는 &quot;최소화&quot;필요한 다양성의 최소 수. 이 K보다 많은 경우, 네트워크가 정지한다는 것을 의미한다. 이 서명자는 기계의 가동 시간은 보장에 의해 해결되어야하며, 기계가 너무 많이 전에 장애 발생 (# 225 (코멘트)) 밖으로 투표 시간에 실패합니다.

- 제안은 단지 쓰레기를 만들 수 testnet 공격자의 효과적인 사용과 같이 &quot;합법적&quot;스팸 문제를 해결하지 않습니다,하지만 포로 광산이없는 경우, 공격자는 공격 제한 에테르를 얻을 수없는 경우가 있습니다. 하나의 가능성은 계정 기초하여 에테르를 수득하는 방법을 제공하는 한정 방식으로 (예를 들어, 10 회) (# 225 (평가)) GitHub의 (또는 다른 방법)이다.

- 그것은 그 시간에 제안 된 각 시대를 만들 수있는 권한을 부여받은 서명자 체크 포인트 블록의 목록을 포함했다. 이 고객이 나중에 불이 필요없이, &quot;동기화 여기에서&quot;이 원점에서 시작했다 할 수 있습니다. 이 extradata 필드 (# 225 (코멘트))에 접두사로 서명하기 전에 추가 할 수 있습니다.


## 파벌 POA 일관성 프로토콜 (파벌 증명 권한 합의 프로토콜)
우리는 다음과 같은 상수를 정의 :

- EPOCH_LENGTH : 체크 포인트 및 대기 투표를 재설정 블록의 수.
	- 30,000 권장, 획기적인 유사하고 ethhash 주요 네트워크
- BLOCK_PERIOD : 타임 스탬프의 두 개의 연속 된 블록 사이의 최소 차이.
	- 유사한 추천 (15)는, 획기적인 및 주요 네트워크를 ethhash하기
- EXTRA_VANITY : 예약 ExtraData 접두사 바이트 서명자 허영의 고정 된 수의.
	- 32 바이트는 같은 길이와 현재 ExtraData에 대한 제안했다.
- EXTRA_SEAL : 서명자 고정 된 수의 추가적인 데이터 바이트 접미사 유지 밀봉.
	- 65 바이트의 표준 기반 secp256k1 곡선을 서명을 저장합니다.
- NONCE_AUTH : 매직 임의의 숫자는 새로운 서명자를 추가 투표를 내지 0xFFFFFFFFFFFFFFFF.
- NONCE_DROP : 매직 난수 0x0000000000000000은 서명자가 투표를 제거합니다.
- UNCLE_HASH : 삼촌 항상 Keccak256 (RLP ([])) 펑 외부 의미 없음.
- DIFF_NOTURN : 서명이 현재 자신의 차례가 아닌 경우는, 서명 블록의 어려움은 어려움이다.
	- 1 추천이 필요하기 때문에 임의의 정수 기준이다.
- DIFF_INTURN : 현재 서명, 서명의 다음 난이도로 설정합니다.
	- 추천 2, 그것은 서명자가 어려움을 설정하지 않고보다 높은 수 있도록.

우리는 또한 각 블록에 대해 다음 상수를 정의합니다 :

- BLOCK_NUMBER : 체인 블록의 높이, 블록 생성의 높이가 0이다.
- SIGNER_COUNT : 서명자 인증의 구체 예에서 체인의 올바른 블록 수.
- SIGNER_INDEX : 승인의 현재 정렬 서명자 지수의 목록을 표시합니다.
- SIGNER_LIMIT : 모든 너무 많은 블록, 서명자가 하나의 서명 할 수 있습니다.
	- 바닥이 있어야 (SIGNER_COUNT / 2) 순서로 한 많은 서명이 합의 된 해결에 도달 할 수 있습니다.

우리는 다음과 같은 블록 헤더 필드 지역을 용도 변경 :

- 수혜자 : 제안 된 변경 사항은 인증 된 서명자 목록을 해결합니다.
	- 투표 때 제로 정상에 작성해야 만 수정했습니다.
	- 그럼에도 불구하고, 투표 메커니즘을 둘러싼 추가적인 복잡성을 피하기 위해, 모든 값을 (심지어 의미없는 값, 예를 들어, 비 서명자 캐스팅) 허용합니다.
	- 요구 (즉, 에포크 변환) 체크 포인트는 블록에서 제로로 채워진다.
- 비표 : 현장에서 정의 된 수혜자의 계정에 대한 서명자 제안.
	- NONCE_DROP는이 서명자와 수혜자의 승인 기존 폐지 제안했다.
	- 새로운 수익 허가 서명자으로 제안 NONCE_AUTH.
	- 체크 포인트는 블록을 제로 충전을해야합니다.
	- 두 (현재)에 더하여, 또는 다른 값을 사용한다.
- extraData : 필드의 허영, 검사 점 및 서명자 서명 조합.
	- 제 EXTRA_VANITY 바이트 (고정 길이) 어떤 서명자 허영 데이터를 포함 할 수있다.
	- EXTRA_SEAL 마지막 바이트 (고정 길이) 헤더 서명 서명을 밀봉한다.
	- 검사는 서명 블록리스트 (N * 20 바이트), 또는 생략을 포함한다.
	- 차단 목록에서 체크 포인트 서명자 추가 데이터 부분은 오름차순으로 정렬해야합니다.
- mixHash : 분기에 보호를받습니다. 추가 데이터는 다오와 유사하다
	- 그것은 정상 작동 중에 0으로 채워해야합니다.
- ommersHash : 포로뿐만 아니라, 아저씨는 t이 이해가되지 않기 때문에, UNCLE_HASH해야합니다.
- 타임 스탬프 : 적어도 수 상위 타임 스탬프 + BLOCK_PERIOD을 차단해야합니다.
- 난이도 : 품질 유도 쇄를 포함하는 별도의 블록 점수.
	- BLOCK_NUMBER의 %의 SIGNER_COUNT하면! = SIGNER_INDEX를, 그것은 DIFF_NOTURN한다
	- BLOCK_NUMBER의 %의 SIGNER_COUNT == SIGNER_INDEX, 당신은 DIFF_INTURN해야하는 경우


### Authorizing a block
네트워크 라이센스를 차단하려면, 서명자는 서명 자체보다 다른 모든 유형의 콘텐츠에 서명해야합니다. 이것은 각각의 필드뿐만 아니라 65 바이트 서명 접미사 extraData 이외에 (논스 및 mixDigest 포함) 헤더 영역의 해시를 포함한다는 것을 의미한다. 그 옐로우 북에 따라 정의 해시 시퀀스에서 이러한 필드.

(V는 0이고, R, S, V, 1) 65 바이트 얻어진 서명이 서명 65 바이트 뒤에 접미사로 extraData secp256k1 표준 곡선을 사용하여 해시.

악의적 인 서명자 (서명 키 손실) 네트워크에 파괴되지 않도록하기 위해, 각 서명자는 SIGNER_LIMIT 연속 블록 하나에 가입 할 수 있습니다. 순서는 고정되어 있지 않고, (DIFF_INTURN)의 이상 (DIFF_NOTURN)보다 더 어려운 높은 블록을 확인 서명자

#### 권한 부여 정책

한 서명자가 이러한 사양을 충족, 그들은 권한을 부여하고 해당 블록을 그들의 관점을 할당 할 수 있습니다, 다음과 같은 정책 권고는 네트워크 트래픽과 포크를 감소시킬 것이다, 그래서 이것은 제안 기능입니다 :

- 서명자가 블록 (그리고 더 최근의 서명 인증 목록)에 서명하도록 허용합니다.
	- 다음 블록을 계산하는 가장 좋은 시간이다 서명 (부모 + BLOCK_PERIOD).
	- 당신이 설정 한 경우, 도착의 정확한 시간을 기다리고, 서명하고 즉시 재생할 수 있습니다.
	- 당신이 너무 오래 시간 서명, 지연 랜드 (SIGNER_COUNT *은 500ms)으로 변경되어 있지 않은 경우.
이 작은 전략은 보장 것이다 서명 및 외부 회전 서명자의 보급을 통해 약간의 우위 (무거운 블록) 서명자의 현재의 차례. 또한, 프로그램은 서명자의 수와 특정 크기에 따라 증가 할 수있다.

### 서명을 투표

체크 포인트 무 상태로 (창조 블록 포함) 각 시대의 변환은 클라이언트가 이전 상태를 필요없이 동기화 할 수있는 능력이 있어야합니다. 이것은 새로운 시대 헤더가 커밋되지 않은 모든 투표가 삭제됩니다, 투표를 포함, 스크래치 카운트에서 시작되지해야한다는 것을 의미합니다.

이외의 모든 시대의 변환 블록의 경우 :

- 서명자 인증 목록에 대한 변경을 제안 자체 서명 블록 투표를 사용할 수 있습니다.
- 만 투표에 최신을 유지하기 위해 각 제안하십시오.
- 진보의 체인으로, 투표는 (제안서를 동시에 제출을 허용) 적용됩니다.
- 즉시 합의 제안 SIGNER_LIMIT 효과에 도달한다.
- 단순 잘못된 클라이언트 구현에 대한 제안은 처벌되지 않습니다.


** 효과 제안 (또는에 대한 중 하나) 제안에 대한 모든 의결권을 포기하는 것을 의미하고, 명확한 목록에서 시작합니다. **

### 캐스케이드 투표

서명이 허가를 취소하는 동안 복잡한 경우가 발생할 수 있습니다. 이전에 승인 된 서명자가 취소 된 경우, 제안의 승인에 필요한 서명자의 수를 감소시킬 수있다. 이 합의에 도달하기 위해 하나 개 이상의 출원 제안 될 수 있습니다, 이러한 제안의 구현은 더 새로운 제안에 영향을 미칠 수 있습니다.

이러한 상황에 대처하기 위해, (새로운 서명자를 추가 대 기존의 스폰서를 삭제, 예를 들어) 같은 시간에 의해 제안 충돌 할 때 여러 것은 명확하지 않다, 평가의 순서는 완전히 최종 승인 목록의 결과를 변경할 수 있습니다. 서명이 스스로 모든 블록, &quot;첫 번째&quot;할 것이다, 그래서 제안을 자신의 투표를 반대 할 수 있기 때문에 그리 명확하지 않다.

캐스케이드의 이행으로 인한 불량을 방지하기 위해, 용액을 명시 계단식 효과를 금지한다. 즉 :은 현재 타이틀 / 투표 수혜자는 인증 목록에 추가되거나 승인 된 목록에서 삭제. 이 후, 합의에 도달하기 위해 다른 제안을 발생하면 때 각각의 수혜자 이러한 제안이 수행 될 것임을 다시 &quot;트리거&quot;(이 시점에서 대부분의 사람들로 여전히 합의).

### 투표 정책

블록 체인이 매우 작은 reorgs, 그래서를 가질 수 있기 때문에 &quot;캐스트 앤 잊지&quot;블록 투표를 포함하는 싱글 체인의 마지막 말하지 않을 수 있습니다으로 순진 투표 메커니즘, 최적이 아닐 수도 있습니다.

그러나 간단한 전략 작업은 사용자가 서명자에 (예 : &quot;추가 0X ...&quot;, &quot;드롭 0X ...&quot;등) &quot;제안&quot;을 구성 할 수 있도록하는 것입니다. 각각의 기호와 주입이 임의의 추천을 선택할 수, 코드에 서명합니다. 이것은 여러 개의 동시 제안 및 reorgs 결국 체인에주의 할 것을 보장한다.

이 목록은 / 시대가 만료 블록의 특정 숫자 후이 될 수 있지만 그것이 재 조립 할 수없는 것은 아닙니다 제안을 통해 &quot;참조&quot;고 인식하는 것이 중요하다, 이렇게 할 경우에 제안은 즉시 포기해서는 안된다.


